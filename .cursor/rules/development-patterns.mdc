---
description:
globs:
alwaysApply: false
---
# Patrones de Desarrollo - VML.Perito

## Convenciones de Nomenclatura

### Backend

#### Archivos y Directorios
- **Modelos**: `camelCase.js` (ej: `user.js`, `rolePermission.js`)
- **Controladores**: `camelCaseController.js` (ej: `userController.js`)
- **Middleware**: `camelCase.js` (ej: `rbac.js`, `permissionRegistry.js`)
- **Rutas**: Agrupadas en el archivo principal [apps/server/index.js](mdc:apps/server/index.js)

#### Variables y Funciones
```javascript
// camelCase para variables y funciones
const userName = 'admin';
const getUserById = async (id) => { ... };

// PascalCase para clases y constructores
class UserController extends BaseController { ... }

// UPPER_SNAKE_CASE para constantes
const JWT_SECRET = process.env.JWT_SECRET;
```

#### Permisos RBAC
```javascript
// Patrón: recurso.accion
'users.read'        // Ver usuarios
'users.create'      // Crear usuarios
'roles.update'      // Actualizar roles
'system.read'       // Ver datos del sistema
```

### Frontend

#### Archivos y Componentes
- **Componentes**: `PascalCase.jsx` (ej: `UserProfile.jsx`)
- **Hooks**: `use-kebab-case.js` (ej: `use-permissions.js`)
- **Contextos**: `kebab-case-context.jsx` (ej: `auth-context.jsx`)
- **Páginas**: `PascalCase.jsx` (ej: `Dashboard.jsx`)

## Patrones de Controladores

### 1. BaseController Pattern
Todos los controladores heredan de [apps/server/controllers/baseController.js](mdc:apps/server/controllers/baseController.js):

```javascript
import { BaseController } from './baseController.js';
import MyModel from '../models/myModel.js';

class MyController extends BaseController {
    constructor() {
        super(MyModel);
        
        // IMPORTANTE: Bind de métodos para preservar contexto
        this.index = this.index.bind(this);
        this.store = this.store.bind(this);
        this.update = this.update.bind(this);
        this.destroy = this.destroy.bind(this);
        this.customMethod = this.customMethod.bind(this);
    }
    
    // Sobrescribir métodos base si es necesario
    async store(req, res) {
        try {
            // Lógica personalizada
            const item = await this.model.create(req.body);
            
            // Notificación WebSocket si aplica
            if (webSocketSystem.isInitialized()) {
                await webSocketSystem.sendNotification(userId, {
                    type: 'system',
                    title: 'Elemento creado',
                    message: 'Se ha creado un nuevo elemento.'
                });
            }
            
            res.status(201).json(item);
        } catch (error) {
            res.status(400).json({ 
                message: 'Error al crear elemento', 
                error: error.message 
            });
        }
    }
}

export default new MyController();
```

### 2. Binding de Métodos Obligatorio
```javascript
// SIEMPRE hacer bind en el constructor para evitar pérdida de contexto
constructor() {
    super(Model);
    this.index = this.index.bind(this);
    this.store = this.store.bind(this);
    // ... todos los métodos públicos
}
```

## Patrones de Rutas

### 1. Protección con RBAC
```javascript
import { requirePermission } from './middleware/rbac.js';

// Patrón estándar para rutas protegidas
app.get('/api/resource', requirePermission('resource.read'), controller.index);
app.post('/api/resource', requirePermission('resource.create'), controller.store);
app.put('/api/resource/:id', requirePermission('resource.update'), controller.update);
app.delete('/api/resource/:id', requirePermission('resource.delete'), controller.destroy);
```

### 2. Orden de Rutas Importante
```javascript
// IMPORTANTE: Rutas específicas ANTES que rutas con parámetros
app.get('/api/users/profile', requirePermission('users.read'), userController.profile);
app.get('/api/users/trashed/all', userController.indexWithTrashed);
app.get('/api/users/:id', userController.show); // Esta va al final
```

## Patrones de Modelos Sequelize

### 1. Definición de Modelos
```javascript
import { DataTypes } from 'sequelize';
import sequelize from '../config/database.js';

const MyModel = sequelize.define('MyModel', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    name: {
        type: DataTypes.STRING,
        allowNull: false,
        validate: {
            notEmpty: true,
            len: [2, 100]
        }
    },
    // Campos de auditoría automáticos
    created_at: {
        type: DataTypes.DATE,
        defaultValue: DataTypes.NOW
    },
    updated_at: {
        type: DataTypes.DATE,
        defaultValue: DataTypes.NOW
    }
}, {
    tableName: 'my_models',
    timestamps: true,
    paranoid: true, // Soft deletes
    createdAt: 'created_at',
    updatedAt: 'updated_at',
    deletedAt: 'deleted_at'
});

export default MyModel;
```

### 2. Relaciones en models/index.js
```javascript
// Definir todas las relaciones en apps/server/models/index.js
User.belongsToMany(Role, {
    through: UserRole,
    foreignKey: 'user_id',
    otherKey: 'role_id',
    as: 'roles'
});
```

## Patrones Frontend React

### 1. Componentes con RBAC
```javascript
import PermissionGate from '../components/PermissionGate.jsx';
import { useRBAC } from '../contexts/rbac-context.jsx';

function MyComponent() {
    const { hasPermission } = useRBAC();
    
    return (
        <div>
            {/* Renderizado condicional */}
            {hasPermission('users.create') && (
                <CreateUserButton />
            )}
            
            {/* O usando PermissionGate */}
            <PermissionGate permission="users.read">
                <UsersList />
            </PermissionGate>
        </div>
    );
}
```

### 2. Hooks Personalizados
```javascript
// Patrón para hooks personalizados
import { useState, useEffect } from 'react';
import { useAuth } from '../contexts/auth-context.jsx';

export function useCustomHook() {
    const { token } = useAuth();
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        // Lógica del hook
    }, [token]);
    
    return { data, loading, error };
}
```

## Patrones de WebSockets

### 1. Integración en Controladores
```javascript
import webSocketSystem from '../websocket/index.js';

// Patrón para notificaciones automáticas
async store(req, res) {
    try {
        const item = await this.model.create(req.body);
        
        // Notificación automática
        if (webSocketSystem.isInitialized()) {
            await webSocketSystem.sendNotificationToRole('admin', {
                type: 'system',
                title: 'Nuevo elemento',
                message: `Se ha creado: ${item.name}`,
                priority: 'normal'
            });
        }
        
        res.status(201).json(item);
    } catch (error) {
        res.status(400).json({ message: 'Error', error: error.message });
    }
}
```

### 2. Eventos Personalizados
```javascript
// Registrar eventos personalizados
const socketManager = webSocketSystem.getSocketManager();

socketManager.registerEventHandler('mi_evento', async (socket, data) => {
    // 1. Verificar permisos
    if (!socket.userPermissions.includes('mi_permiso')) {
        socket.emit('error', { message: 'Sin permisos' });
        return;
    }
    
    // 2. Validar datos
    if (!data || !data.campo) {
        socket.emit('error', { message: 'Datos inválidos' });
        return;
    }
    
    // 3. Procesar lógica
    const resultado = await procesarLogica(data);
    
    // 4. Responder
    socket.emit('mi_respuesta', resultado);
});
```

## Manejo de Errores

### 1. Backend - Respuestas Estándar
```javascript
// Patrón de respuestas de error
try {
    // Lógica
} catch (error) {
    res.status(400).json({
        message: 'Descripción amigable del error',
        error: error.message,
        timestamp: new Date().toISOString()
    });
}
```

### 2. Frontend - Manejo de Errores
```javascript
// Patrón para manejo de errores en fetch
try {
    const response = await fetch('/api/endpoint', {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    });
    
    if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Error en la petición');
    }
    
    const result = await response.json();
    return result;
} catch (error) {
    console.error('Error:', error.message);
    // Mostrar error al usuario
    showNotification({
        type: 'error',
        message: error.message
    });
}
```

## Validación de Datos

### 1. Backend - Validación en Modelos
```javascript
// Usar validaciones de Sequelize
const MyModel = sequelize.define('MyModel', {
    email: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
        validate: {
            isEmail: true,
            notEmpty: true
        }
    },
    age: {
        type: DataTypes.INTEGER,
        validate: {
            min: 0,
            max: 120
        }
    }
});
```

### 2. Frontend - Validación en Formularios
```javascript
// Patrón de validación en React
const [errors, setErrors] = useState({});

const validateForm = (data) => {
    const newErrors = {};
    
    if (!data.name?.trim()) {
        newErrors.name = 'El nombre es requerido';
    }
    
    if (!data.email?.includes('@')) {
        newErrors.email = 'Email inválido';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
};
```

## Testing

### 1. Scripts de Prueba
```javascript
// Patrón para scripts de prueba del backend
import http from 'http';

async function testEndpoint() {
    try {
        // 1. Hacer login
        const token = await login();
        
        // 2. Probar endpoint
        const result = await makeRequest('/api/endpoint', token);
        
        // 3. Verificar resultado
        console.log('✅ Prueba exitosa:', result);
    } catch (error) {
        console.error('❌ Prueba falló:', error.message);
    }
}
```

## Seguridad

### 1. Principios de Seguridad
- **Autenticación**: JWT obligatorio en todas las rutas protegidas
- **Autorización**: RBAC en backend Y frontend
- **Validación**: Datos validados en ambos extremos
- **Sanitización**: Limpiar datos de entrada
- **Principio de menor privilegio**: Permisos mínimos necesarios

### 2. Checklist de Seguridad
- [ ] Ruta protegida con `requirePermission()`
- [ ] Validación de datos en modelo Sequelize
- [ ] Verificación de permisos en frontend
- [ ] Manejo de errores sin exponer información sensible
- [ ] Logs de accesos y errores
- [ ] Tokens JWT con expiración apropiada

## Performance

### 1. Optimizaciones Backend
- Usar `attributes: { exclude: ['password'] }` en consultas de usuarios
- Incluir relaciones solo cuando sea necesario
- Implementar paginación en listados grandes
- Usar índices en campos de búsqueda frecuente

### 2. Optimizaciones Frontend
- Lazy loading de componentes pesados
- Memoización con `useMemo` y `useCallback`
- Evitar re-renders innecesarios
- Optimizar imágenes y assets
